# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'src.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

'''
author:Jimmy
此程序仅用于学习
'''



import traceback
from PyQt5 import QtCore, QtGui, QtWidgets
import sys
import drawBackground
import GraphicVeiw
import math
import numpy as np
import time
class Ui_MainWindow(QtWidgets.QMainWindow):
    def setupUi(self):
        self.limit = 0.00001       #死区
        self.transformerlist2 = [] #双绕组变压器控件的容器
        self.transformerlist3 = []
        self.generatorlist = []
        self.loaderlist = []
        self.nodelist = []
        self.wirelist = []
        self.setWindowTitle("jimmy仿真软件")
        #窗口设置大小
        self.desktop = QtWidgets.QDesktopWidget().availableGeometry()

        self.resize(self.desktop.width(), self.desktop.height())     #获得窗口大小
        #self.move(self.desktop.center() - self.rect().center())

        #控件文本
        self.textEdit = QtWidgets.QTextBrowser(self)

        self.textEdit.setObjectName("textEdit")
        self.textEdit.ensureCursorVisible()
        #self.textEdit.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)

        #菜单
        self.menubar = QtWidgets.QMenuBar(self)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 900, 26))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menulibrary = QtWidgets.QMenu(self.menubar)
        self.menulibrary.setObjectName("menulibrary")
        self.menusimulate = QtWidgets.QMenu(self.menubar)
        self.menusimulate.setObjectName("menusimulate")
        self.menuview = QtWidgets.QMenu(self.menubar)
        self.menuview.setObjectName("menuview")
        self.setMenuBar(self.menubar)

        self.statusbar = QtWidgets.QStatusBar(self)
        self.statusbar.setObjectName("statusbar")
        self.setStatusBar(self.statusbar)
        #菜单动作
        self.actionsave = QtWidgets.QAction(self)
        self.actionsave.triggered.connect(self.func_save)
        self.actionsave.setObjectName("actionsave")
        self.actionopen = QtWidgets.QAction(self)
        self.actionopen.triggered.connect(self.func_open)
        self.actionopen.setObjectName("actionopen")
        self.actionlibrary = QtWidgets.QAction("gory")
        self.actionlibrary.triggered.connect(self.func_library)

        self.actionsimular = QtWidgets.QAction("run")
        self.actionsimular.triggered.connect(self.func_run)

        self.actionview = QtWidgets.QAction("ad_matrix")
        self.actionview.triggered.connect(self.func_martix)

        self.menuFile.addAction(self.actionsave)
        self.menuFile.addAction(self.actionopen)
        self.menulibrary.addAction(self.actionlibrary)
        self.menusimulate.addAction(self.actionsimular)
        self.menuview.addAction(self.actionview)

        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menulibrary.menuAction())
        self.menubar.addAction(self.menusimulate.menuAction())
        self.menubar.addAction(self.menuview.menuAction())

        self.centralwidget = QtWidgets.QWidget(self)
        self.centralwidget.setObjectName("centralwidget")
        #背景
        self.scene = drawBackground.GraphicScene(self)
        self.view = GraphicVeiw.GraphicView(self.scene, parent=self.centralwidget)
        self.view.setScene(self.scene)
        #self.view.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.view.setDragMode(self.view.RubberBandDrag)
        self.view.setGeometry(QtCore.QRect(0, 26, self.desktop.width(), int((self.desktop.height())*0.75)))

        #text显示区
        self.textEdit.setGeometry(QtCore.QRect(0, int(self.desktop.height()*0.75+50), self.desktop.width(), int((self.desktop.height())*0.25)))
        self.textEdit.setEnabled(False)
        self.setCentralWidget(self.centralwidget)
        self.retranslateUi()
        QtCore.QMetaObject.connectSlotsByName(self)
        #导纳矩阵显示窗口
        self.view_dialog = QtWidgets.QDialog()
        self.view_dialog.setWindowTitle("martix")
        self.view_dialog.resize(1000 ,500)
        self.textEdit_view = QtWidgets.QTextBrowser(self.view_dialog)
        self.textEdit_view.ensureCursorVisible()
        self.textEdit_view.setGeometry(QtCore.QRect(0, 0, self.view_dialog.size().width(), self.view_dialog.size().height()))
        self.textEdit_view.setEnabled(False)

        self.simulate_dialog = QtWidgets.QDialog()
        self.simulate_dialog.setWindowTitle("config")
        self.lineedite = QtWidgets.QLineEdit()
        self.simulate_button = QtWidgets.QPushButton("run")
        self.simulate_button.clicked.connect(self.button_task)
        Layout = QtWidgets.QFormLayout(self)
        Layout.addRow("limit", self.lineedite)
        Layout.addRow("", self.simulate_button)
        self.simulate_dialog.setLayout(Layout)

    def button_task(self):
        self.limit = eval(self.lineedite.text())
        #print(self.limit)
        self.kernel()
        #self.textEdit.append("run")
        for i in self.transformerlist2:
            i.trans_2.update()
        for i in self.nodelist:
            i.node.update()
        for i in self.transformerlist3:
            i.trans_3.update()
        for i in self.wirelist:
            i.wire.update()
        self.simulate_dialog.close()


    def retranslateUi(self):
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.menulibrary.setTitle(_translate("MainWindow", "library"))
        self.menusimulate.setTitle(_translate("MainWindow", "simulate"))
        self.menuview.setTitle(_translate("MainWindow", "view"))
        self.actionsave.setText(_translate("MainWindow", "save"))
        self.actionopen.setText(_translate("MainWindow", "open"))


    def func_save(self):
        pass

    def func_open(self):
        pass

    def func_run(self):
        self.lineedite.setText("0.00001")
        self.simulate_dialog.show()
        # self.kernel()
        # #self.textEdit.append("run")
        # for i in self.transformerlist2:
        #     i.trans_2.update()
        # for i in self.nodelist:
        #     i.node.update()
        # for i in self.transformerlist3:
        #     i.trans_3.update()
        # for i in self.wirelist:
        #     i.wire.update()

    def func_martix(self):
        self.view_dialog.show()
    #元件库
    def func_library(self):
        #元器件库
        self.widget = QtWidgets.QWidget()
        self.widget.resize(int(self.desktop.width()/6), int(self.desktop.height()))
        self.items = QtWidgets.QDockWidget("gory", self)#
        self.items.setFixedSize(int(self.desktop.width()/6), int(self.desktop.height()))

        self.pushbutton1 = QtWidgets.QPushButton("transformer2", self.widget)
        self.pushbutton1.move(0, 0)
        self.pushbutton1.resize(int(self.desktop.width()/6), int(self.desktop.height()/6))
        self.pushbutton1.setIcon(QtGui.QIcon(QtGui.QPixmap("./image/transformer.png")))
        self.pushbutton1.clicked.connect(self.trans2)

        self.pushbutton2 = QtWidgets.QPushButton("transformer3", self.widget)
        self.pushbutton2.setIcon(QtGui.QIcon(QtGui.QPixmap("./image/transformer3.png")))
        self.pushbutton2.resize(int(self.desktop.width()/6), int(self.desktop.height()/6))
        self.pushbutton2.move(0, int(self.desktop.height()/6))
        self.pushbutton2.clicked.connect(self.trans3)

        self.pushbutton3 = QtWidgets.QPushButton("generator", self.widget)
        self.pushbutton3.setIcon(QtGui.QIcon(QtGui.QPixmap("./image/generator.png")))
        self.pushbutton3.resize(int(self.desktop.width()/6), int(self.desktop.height()/6))
        self.pushbutton3.move(0, int(2*self.desktop.height()/6))
        self.pushbutton3.clicked.connect(self.gene)

        self.pushbutton4 = QtWidgets.QPushButton("loader", self.widget)
        self.pushbutton4.setIcon(QtGui.QIcon(QtGui.QPixmap("./image/loader.png")))
        self.pushbutton4.resize(int(self.desktop.width()/6), int(self.desktop.height()/6))
        self.pushbutton4.move(0, int(3*self.desktop.height()/6))
        self.pushbutton4.clicked.connect(self.loader)
        self.items.setWidget(self.widget)

        self.pushbutton5 = QtWidgets.QPushButton("wire", self.widget)
        self.pushbutton5.setIcon(QtGui.QIcon(QtGui.QPixmap("./image/wire.png")))
        self.pushbutton5.resize(int(self.desktop.width()/6), int(self.desktop.height()/6))
        self.pushbutton5.move(0, int(4*self.desktop.height()/6))
        self.pushbutton5.clicked.connect(self.wire)
        self.items.setWidget(self.widget)

        self.pushbutton6 = QtWidgets.QPushButton("node", self.widget)
        self.pushbutton6.setIcon(QtGui.QIcon(QtGui.QPixmap("./image/node.png")))
        self.pushbutton6.resize(int(self.desktop.width()/6), int(self.desktop.height()/6))
        self.pushbutton6.move(0, int(5*self.desktop.height()/6))
        self.pushbutton6.clicked.connect(self.func_Node)
        self.items.setWidget(self.widget)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.items)
    #双绕组变压器控件创建
    def trans2(self):
        item = GraphicVeiw.GraphicItem_trans2(address="./image/model2.png")
        item.setPos(0, 0)
        item.trans_2.index = len(self.transformerlist2)+1
        item.trans_2.setWindowTitle(str(item.trans_2.index))
        self.scene.add_node(item)
        self.transformerlist2.append(item)
        #print(item.trans_2.index)


    def trans3(self):
        item = GraphicVeiw.GraphicItem_trans3(address="./image/model3.png")
        item.setPos(0, 0)
        item.trans_3.index = len(self.transformerlist3)+1
        item.trans_3.setWindowTitle(str(item.trans_3.index))
        self.scene.add_node(item)
        self.transformerlist3.append(item)
        #print(item.trans_3.index)

    def gene(self):
        item = GraphicVeiw.GraphicItem_gene(address="./image/generator.png")
        item.setPos(0, 0)
        item.gene.index = len(self.generatorlist)+1
        item.gene.setWindowTitle(str(item.gene.index))
        self.scene.add_node(item)
        self.generatorlist.append(item)
        #print(item.gene.index)

    def loader(self):
        item = GraphicVeiw.GraphicItem_loader(address="./image/loader.png")
        item.setPos(0, 0)
        item.load.index = len(self.loaderlist)+1
        item.load.setWindowTitle(str(item.load.index))
        self.scene.add_node(item)
        self.loaderlist.append(item)
        #print(item.load.index)

    def wire(self):
        item = GraphicVeiw.GraphicItem_wire(address="./image/model.png")
        item.setPos(0, 0)
        item.wire.index = len(self.wirelist)+1
        item.wire.setWindowTitle(str(item.wire.index))
        self.scene.add_node(item)
        self.wirelist.append(item)
        #print(item.wire.index)

    def func_Node(self):
        item = GraphicVeiw.GraphicItem_node(address="./image/node.png")
        item.setPos(0, 0)
        item.node.index = len(self.nodelist)+1
        item.node.setWindowTitle(str(item.node.index))
        self.scene.add_node(item)
        self.nodelist.append(item)
        #print(item.node.index)

    #核心轮询函数
    def kernel(self):
        self.caculate_vb()#获取电压基准值
        self.caculate_trans2()#标幺化
        self.caculate_wire()
        self.cacualate_trans_3()
        self.admit_matrix_caculate()#导纳矩阵生成
        self.print_matrix()
        self.P_Q_u_angle_init()#初始化 P Q U ANGEL矩阵
        self.caulcunate_kernel()#牛拉法求解

    #获取基准电压
    def caculate_vb(self):
        for i in self.transformerlist3:
            i.trans_3.left_vb = (1/1.05)*eval(i.trans_3.ratio.split("/")[0])
            i.trans_3.down_vb = (1/1.1)*eval(i.trans_3.ratio.split("/")[1])
            i.trans_3.right_vb = (1/1.1)*eval(i.trans_3.ratio.split("/")[2])
            if i.left_node_index !=0: self.nodelist[i.left_node_index-1].node.vb = i.trans_3.left_vb
            if i.down_node_index !=0: self.nodelist[i.down_node_index-1].node.vb = i.trans_3.down_vb
            if i.right_node_index !=0: self.nodelist[i.right_node_index-1].node.vb = i.trans_3.right_vb
        for i in self.generatorlist:
            if i.left_node_index != 0 : self.nodelist[i.left_node_index-1].node.vb = eval(i.gene.V)
            if i.right_node_index != 0 : self.nodelist[i.right_node_index-1].node.vb = eval(i.gene.V)
        for i in self.wirelist:
            if self.nodelist[i.right_node_index-1].node.vb != 0:
                i.wire.vb = self.nodelist[i.right_node_index-1].node.vb
            if self.nodelist[i.left_node_index-1].node.vb != 0:
                i.wire.vb = self.nodelist[i.left_node_index-1].node.vb
            for j in self.generatorlist:
                if (i.left_node_index == j.left_node_index)|(i.left_node_index == j.right_node_index):
                    if i .left_node_index != 0:
                        i.wire.vb = eval(j.gene.V)
                if (i.right_node_index == j.left_node_index)|(i.right_node_index == j.right_node_index):
                    if i .right_node_index != 0:
                        i.wire.vb = eval(j.gene.V)

            self.nodelist[i.left_node_index-1].node.vb = i.wire.vb
            self.nodelist[i.right_node_index-1].node.vb = i.wire.vb
        for i in self.transformerlist2:
            if i.right_node_index != 0 : i.trans_2.right_vb = self.nodelist[i.right_node_index-1].node.vb
            if i.left_node_index != 0: i.trans_2.left_vb = self.nodelist[i.left_node_index-1].node.vb
        for i in self.transformerlist3:
            if i.left_node_index != 0 :i.trans_3.left_vb = self.nodelist[i.left_node_index-1].node.vb
            if i.right_node_index != 0 :i.trans_3.right_vb = self.nodelist[i.right_node_index-1].node.vb
            if i.down_node_index != 0 : i.trans_3.down_vb = self.nodelist[i.down_node_index-1].node.vb
        for i in self.wirelist:
            if i.left_node_index != 0: i.wire.vb = self.nodelist[i.left_node_index-1].node.vb
        for i in self.transformerlist3:
            i.trans_3.left_vb = 1
            i.trans_3.right_vb = 1
            i.trans_3.down_vb = 1

    #双绕组变压器导纳计算 标幺值
    def caculate_trans2(self):
        for i in self.transformerlist2:
            i.trans_2.Rt = float((eval(i.trans_2.PK)*pow(eval(i.trans_2.ratio.split("/")[0]),2))/(1000*pow(eval(i.trans_2.SN),2)))
            i.trans_2.Xt = float((eval(i.trans_2.UK)*pow(eval(i.trans_2.ratio.split("/")[0]),2))/(100*eval(i.trans_2.SN)))
            i.trans_2.Bm = float((eval(i.trans_2.I0)*eval(i.trans_2.SN))/(100*pow(eval(i.trans_2.ratio.split("/")[0]),2)))
            i.trans_2.Gm = float((eval(i.trans_2.P0))/(1000*pow(eval(i.trans_2.ratio.split("/")[0]), 2)))
            i.trans_2.Z = complex(i.trans_2.Rt, i.trans_2.Xt)
            i.trans_2.Y = complex(i.trans_2.Gm, -i.trans_2.Bm)
            #print(i.trans_2.Y)
            #print(i.trans_2.Z)
            i.trans_2.Z_N = i.trans_2.Z*(100/pow(i.trans_2.left_vb, 2))
            i.trans_2.Y_N = i.trans_2.Y/(100/pow(i.trans_2.left_vb, 2))
            Y_T = 1/i.trans_2.Z_N
            if i.trans_2.right_vb !=0 :i.trans_2.K_N =1/((eval(i.trans_2.ratio.split("/")[0])/eval(i.trans_2.ratio.split("/")[1]))/(i.trans_2.left_vb/i.trans_2.right_vb))
            i.trans_2.Y2 = Y_T/i.trans_2.K_N
            i.trans_2.Y1 = Y_T*((i.trans_2.K_N-1)/i.trans_2.K_N)
            i.trans_2.Y3 = Y_T*((1-i.trans_2.K_N)/pow(i.trans_2.K_N,2))

    def caculate_wire(self):
        for i in self.wirelist:
            a = eval(i.wire.length)
            b = eval(i.wire.x1)
            c = eval(i.wire.b1)
            d = eval(i.wire.r1)
            i.wire.Y1N = complex(0, a*c*0.5)*(pow(i.wire.vb, 2)/100)
            i.wire.Y2N = (1/complex(d*a, b*a))*(pow(i.wire.vb, 2)/100)
            i.wire.Y3N = i.wire.Y1N

    def cacualate_trans_3(self):
        for i in self.transformerlist3:
            P12 = eval(i.trans_3.P12)
            P23 = eval(i.trans_3.P23)
            P31 = eval(i.trans_3.P31)
            I0 = eval(i.trans_3.I0)
            P0 = eval(i.trans_3.P0)
            SN1 = eval(i.trans_3.SN1)
            SN2 = eval(i.trans_3.SN2)
            SN3 = eval(i.trans_3.SN3)
            V1 = 1
            v1 = eval(i.trans_3.ratio.split("/")[0])
            V3 = eval(i.trans_3.ratio.split("/")[2])
            V2 = eval(i.trans_3.ratio.split("/")[1])
            v1b = eval(i.trans_3.V1B)
            v2b = eval(i.trans_3.V2B)
            v3b = eval(i.trans_3.V3B)
            V12 = eval(i.trans_3.V12)
            V23 = eval(i.trans_3.V23)
            V31 = eval(i.trans_3.V31)
            a12 = SN1/SN2
            a31 = SN1/SN3
            a23 = SN1/min(SN2, SN3)
            P12 = P12*pow(a12, 2)
            P23 = P23*pow(a23, 2)
            P31 = P31*pow(a31, 2)
            # V12 = V12*a12
            # V23 = V23*a23
            # V31 = V31*a31
            P1 = 0.5*(P12+P31-P23)
            P2 = 0.5*(P23+P12-P31)
            P3 = 0.5*(P31+P23-P12)
            U1 = 0.5*(V12+V31-V23)
            U2 = 0.5*(V12+V23-V31)
            U3 = 0.5*(V31+V23-V12)
            i.trans_3.Y2 = (1/(complex(((P1*pow(V1,2))/(1000*pow(SN1,2))), (U1*pow(V1,2))/(100*SN1))))*(pow(i.trans_3.left_vb,2)/100)
            i.trans_3.Y1 = complex(P0/(1000*pow(V1,2)), -(I0*SN1)/(100*pow(V1,2)))*(pow(i.trans_3.left_vb,2)/100)
            Y12N = (1/(complex(((P2*pow(V1,2))/(1000*pow(SN1,2))), (U2*pow(V1,2))/(100*SN1))))*(pow(i.trans_3.left_vb, 2)/100)
            Y13N = (1/(complex(((P3*pow(V1,2))/(1000*pow(SN1,2))), (U3*pow(V1,2))/(100*SN1))))*(pow(i.trans_3.left_vb, 2)/100)
            K1N = (v1/V1)/v1b
            K12N = (V2/V1)/v2b
            K13N = (V3/V1)/v3b
            i.trans_3.Y3 = Y12N*((K12N-1)/K12N)
            i.trans_3.Y7 = Y12N/K12N
            i.trans_3.Y5 = Y12N*((1-K12N)/pow(K12N, 2))
            i.trans_3.Y4 = Y13N*((K13N-1)/K13N)
            i.trans_3.Y8 = Y13N/K13N
            i.trans_3.Y6 = Y13N*((1-K13N)/pow(K13N, 2))
    #用于下面节点导纳矩阵计算 寻找节点与元件的关系
    def find_node_relation(self, node_num):
        result_list=[]
        for i in range(len(self.transformerlist2)):
            if self.transformerlist2[i].left_node_index == node_num:
                result_list.append((1, i, 1,self.transformerlist2[i].left_node_index ,self.transformerlist2[i].right_node_index))#(1, ,1) 第一个代表双绕组变压器，第二个代表索引，第三个代表左右连接
            if self.transformerlist2[i].right_node_index == node_num:
                result_list.append((1, i, 2,self.transformerlist2[i].left_node_index ,self.transformerlist2[i].right_node_index))
        for i in range(len(self.transformerlist3)):
            if self.transformerlist3[i].left_node_index == node_num:
                result_list.append((2, i, 1,self.transformerlist3[i].left_node_index ,self.transformerlist3[i].down_node_index,self.transformerlist3[i].right_node_index))
            if self.transformerlist3[i].right_node_index == node_num:
                result_list.append((2, i, 3,self.transformerlist3[i].left_node_index ,self.transformerlist3[i].down_node_index,self.transformerlist3[i].right_node_index))
            if self.transformerlist3[i].down_node_index == node_num:
                result_list.append((2, i, 2,self.transformerlist3[i].left_node_index ,self.transformerlist3[i].down_node_index,self.transformerlist3[i].right_node_index))
        for i in range(len(self.wirelist)):
            if self.wirelist[i].left_node_index == node_num:
                result_list.append((3, i, 1,self.wirelist[i].left_node_index ,self.wirelist[i].right_node_index))
            if self.wirelist[i].right_node_index == node_num:
                result_list.append((3, i, 2,self.wirelist[i].left_node_index ,self.wirelist[i].right_node_index))
        return(result_list)


    #节点导纳计算
    def admit_matrix_caculate(self):
        num = len(self.nodelist)
        added_node = len(self.transformerlist3)
        list_relation = []#未包括三绕组变压器引入的节点
        for i in range(num):
            list_relation.append(self.find_node_relation(i+1))

        self.ad_matrix = np.zeros((num+added_node,num+added_node)).astype(np.complex_)
        for i in range(num+added_node):
            for j in range(num+added_node-i):
                if i<num and j<num:#正常节点
                    if i == i+j:#自导纳
                        for x in list_relation[i]:
                            if x[0] == 1:#双绕组变压器
                                if x[2] == 1:
                                    self.ad_matrix[i][i+j] += self.transformerlist2[x[1]].trans_2.Y_N+self.transformerlist2[x[1]].trans_2.Y1+self.transformerlist2[x[1]].trans_2.Y2
                                elif x[2]== 2:
                                    self.ad_matrix[i][i+j] += self.transformerlist2[x[1]].trans_2.Y1+self.transformerlist2[x[1]].trans_2.Y2
                            if x[0] == 2:
                                if x[2] == 1:
                                    self.ad_matrix[i][i+j] += self.transformerlist3[x[1]].trans_3.Y2
                                elif x[2] == 2:
                                    self.ad_matrix[i][i+j] += self.transformerlist3[x[1]].trans_3.Y6+self.transformerlist3[x[1]].trans_3.Y8
                                elif x[2] == 3:
                                    self.ad_matrix[i][i+j] += self.transformerlist3[x[1]].trans_3.Y5+self.transformerlist3[x[1]].trans_3.Y7
                            if x[0] ==3:
                                self.ad_matrix[i][i+j] += self.wirelist[x[1]].wire.Y1N+self.wirelist[x[1]].wire.Y2N
                    if i!=i+j:
                        for x in list_relation[i]:
                            if x[0] != 2 and (x[3] == i+j+1 or x[4] == i+j+1) :
                                if x[0] == 1 :
                                    self.ad_matrix[i][i+j] = -self.transformerlist2[x[1]].trans_2.Y2
                                if x[0] == 3 :
                                    self.ad_matrix[i][i+j] = -self.wirelist[x[1]].wire.Y2N
                                else:
                                    pass

                if i<num and i+j>=num :#正常节点与三绕组变压器导纳
                    for x in list_relation[i]:
                        if x[0] == 2:
                            if x[2] == 1:#一次侧
                                self.ad_matrix[i][i+j] = -self.transformerlist3[x[1]].trans_3.Y2
                            elif x[2] == 2:
                                self.ad_matrix[i][i+j] = -self.transformerlist3[x[1]].trans_3.Y8
                            elif x[2] == 3:#中压
                                self.ad_matrix[i][i+j] = -self.transformerlist3[x[1]].trans_3.Y7
                            else:
                                pass
                if i>=num and i == i+j:
                    self.ad_matrix[i][i+j] = self.transformerlist3[i-num].trans_3.Y3+self.transformerlist3[i-num].trans_3.Y4+self.transformerlist3[i-num].trans_3.Y7+self.transformerlist3[i-num].trans_3.Y8+self.transformerlist3[i-num].trans_3.Y2+self.transformerlist3[i-num].trans_3.Y1
        X = np.triu(self.ad_matrix)
        X += X.T - np.diag(X.diagonal())
        self.ad_matrix=X
    #打印节点导纳矩阵
    def print_matrix(self):
        len = self.ad_matrix.shape[0]
        self.textEdit_view.clear()
        for i in range(len):
            tr = ','.join(str(j) for j in self.ad_matrix[i])
            self.textEdit_view.append(tr)
        #    print(tr)
    #P Q U ANGEK矩阵初始化
    def P_Q_u_angle_init(self):
        node_num = len(self.nodelist)
        self.num = len(self.nodelist)+len(self.transformerlist3)
        for i in self.nodelist:
            if i.node.node_tpye == 1 :
                self.num = self.num+1
            elif i.node.node_tpye == 3:
                self.num = self.num-1
        for i in self.transformerlist3:
            if i.trans_3.node_type == 1:
                self.num = self.num+1
            elif i.trans_3.node_type == 3:
                self.num = self.num-1
        added_node = len(self.transformerlist3)
        self.Ui = np.zeros(node_num+added_node)
        self.Angle = np.zeros( node_num+added_node)
        self.P_Q_real = np.zeros(self.num)
        sumPQ = 0
        sumBalance = 0

        for i in range(len(self.nodelist)):

            if self.nodelist[i].node.node_tpye == 1:
                self.Ui[i] = 1
                self.Angle[i] = 0
                if self.nodelist[i].node.node_p!= "" : self.P_Q_real[i+sumPQ-sumBalance] = eval(self.nodelist[i].node.node_p)/100
                if self.nodelist[i].node.node_q!= "" : self.P_Q_real[i+sumPQ-sumBalance+1] = eval(self.nodelist[i].node.node_q)/100
                sumPQ = sumPQ+1
            if self.nodelist[i].node.node_tpye == 2:
                if self.nodelist[i].node.node_v!="" :self.Ui[i] = self.nodelist[i].node.node_v
                self.Angle[i] = 0
                if self.nodelist[i].node.node_p!="" :self.P_Q_real[i+sumPQ-sumBalance] = eval(self.nodelist[i].node.node_p)/100

            if self.nodelist[i].node.node_tpye == 3:
                if self.nodelist[i].node.node_v!="" :self.Ui[i] = self.nodelist[i].node.node_v
                self.Angle[i]=self.nodelist[i].node.node_angle
                sumBalance = sumBalance+1
        for i in range(len(self.transformerlist3)):
            if self.transformerlist3[i].trans_3.node_tpye == 1:
                self.Ui[node_num+i] = 1
                self.Angle[node_num+i] = 0
                if self.transformerlist3[i].trans_3.node_p!= "" : self.P_Q_real[i+node_num+sumPQ-sumBalance] = eval(self.nodelist[i].node.node_p)/100
                if self.transformerlist3[i].trans_3.node_q!= "" : self.P_Q_real[i+node_num+sumPQ-sumBalance+1] = eval(self.nodelist[i].node.node_q)/100
                sumPQ = sumPQ+1
            if self.transformerlist3[i].trans_3.node_tpye == 2:
                if self.transformerlist3[i].trans_3.node_v!="" :self.Ui[node_num+i] = self.transformerlist3[i].trans_3.node_v
                self.Angle[node_num+i] = 0
                if self.transformerlist3[i].trans_3.node_p!="" :self.P_Q_real[i+node_num+sumPQ-sumBalance] = eval(self.transformerlist3[i].trans_3.node_p)/100

            if self.transformerlist3[i].trans_3.node_tpye == 3:
                if self.transformerlist3[i].trans_3.node_v!="" :self.Ui[node_num+i] = self.transformerlist3[i].trans_3.node_v
                self.Angle[node_num+i]=self.transformerlist3[i].trans_3.node_angle
                if self.transformerlist3[i].trans_3.node_p!="" :self.P_Q_real[i+node_num+sumPQ-sumBalance] = eval(self.transformerlist3[i].trans_3.node_p)/100
                sumBalance = sumBalance+1






    #功率方程计算
    def power_flow_equation(self):
        n=len(self.nodelist)+len(self.transformerlist3)
        num = len(self.nodelist)
        P_Q_calculate = np.zeros(self.num)
        sumPQ = 0
        self.sumBalance = 0

        for i in range(len(self.nodelist)):
            p_sum = 0
            q_sum = 0
            if self.nodelist[i].node.node_tpye == 1:
                for j in range(n):
                    p_sum = p_sum+self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                    q_sum = q_sum+self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                P_Q_calculate[i+sumPQ-self.sumBalance] = self.Ui[i]*p_sum
                P_Q_calculate[i+sumPQ-self.sumBalance+1] = self.Ui[i]*q_sum
                sumPQ = sumPQ+1
            if self.nodelist[i].node.node_tpye == 2:
                for j in range(n):
                    p_sum = p_sum + self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                P_Q_calculate[i+sumPQ-self.sumBalance] = self.Ui[i]*p_sum

            if self.nodelist[i].node.node_tpye == 3:
                self.sumBalance = self.sumBalance+1

        for i in range(len(self.transformerlist3)):
            p_sum = 0
            q_sum = 0
            if self.transformerlist3[i].trans_3.node_tpye == 1:
                for j in range(n):
                    p_sum = p_sum+self.Ui[j]*(self.ad_matrix[num+i][j].real*math.cos(math.radians(self.Angle[num+i]-self.Angle[j]))+self.ad_matrix[num+i][j].imag*math.sin(math.radians(self.Angle[num+i]-self.Angle[j])))
                    q_sum = q_sum+self.Ui[j]*(self.ad_matrix[num+i][j].real*math.sin(math.radians(self.Angle[num+i]-self.Angle[j]))-self.ad_matrix[num+i][j].imag*math.cos(math.radians(self.Angle[num+i]-self.Angle[j])))
                P_Q_calculate[num+i+sumPQ-self.sumBalance] = self.Ui[i+num]*p_sum
                P_Q_calculate[num+i+sumPQ-self.sumBalance+1] = self.Ui[i+num]*q_sum
                sumPQ = sumPQ+1
            if self.transformerlist3[i].trans_3.node_tpye == 2:
                for j in range(n):
                    p_sum = p_sum+self.Ui[j]*(self.ad_matrix[num+i][j].real*math.cos(math.radians(self.Angle[num+i]-self.Angle[j]))+self.ad_matrix[num+i][j].imag*math.sin(math.radians(self.Angle[num+i]-self.Angle[j])))
                P_Q_calculate[i+num+sumPQ-self.sumBalance] = self.Ui[num+i]*p_sum
            if self.transformerlist3[i].trans_3.node_tpye == 3:
                self.sumBalance = self.sumBalance+1


        return (P_Q_calculate)
    #雅各比矩阵计算
    def Jaccobi_calcuate(self):
        n = len(self.nodelist)+len(self.transformerlist3)
        node_num = len(self.nodelist)
        trans_num = len(self.transformerlist3)
        sumPQ_rank = 0
        sumBalance_rank = 0
        Jaccobi_martix = np.zeros((self.num, self.num))
        for i in range(n):
            sumPQ = 0
            sumBalance = 0
            if i < node_num:

                if self.nodelist[i].node.node_tpye == 1:#pq  行pq节点

                    for j in range(n):
                        if j<node_num:

                            if self.nodelist[j].node.node_tpye == 1: # 列 pq节点
                                if i == j:
                                    q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] =self.Ui[i]*q_sum+2*self.Ui[i]*self.Ui[i]*self.ad_matrix[i][i].real
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] =self.Ui[i]*q_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance+1 ]=self.Ui[i]*p_sum-2*self.Ui[i]*self.Ui[i]*self.ad_matrix[i][i].imag
                                if i !=j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] = -Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1]
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance+1 ] = Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance]

                                sumPQ = sumPQ+1

                            if self.nodelist[j].node.node_tpye == 2:#列pv节点
                                if i == j:
                                    q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] =self.Ui[i]*q_sum
                                if i !=j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] = -self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))

                            if self.nodelist[j].node.node_tpye == 3:#列平衡
                                sumBalance = sumBalance+1

                        else:# 列三绕组节点

                            if self.transformerlist3[j-node_num].trans_3.node_type == 1:#pq
                                Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                                Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] = -Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1]
                                Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance+1] = Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance]
                                sumPQ = sumPQ+1

                            if self.transformerlist3[j-node_num].trans_3.node_type == 2:#pv
                                Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] = -self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))

                            if self.transformerlist3[j-node_num].trans_3.node_type == 3:#平衡
                                sumBalance = sumBalance+1
                    sumPQ_rank=sumPQ_rank+1



                if self.nodelist[i].node.node_tpye == 2:#行 pv
                    for j in range(n):
                        if j < node_num:

                            if self.nodelist[j].node.node_tpye == 1:#列pq
                                if i == j:
                                    q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] =self.Ui[i]*q_sum+2*self.Ui[i]*self.Ui[i]*self.ad_matrix[i][i].real
                                if i !=j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))

                                sumPQ = sumPQ+1

                            if self.nodelist[j].node.node_tpye == 2:#列pv
                                if i == j:
                                   # q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                    #        q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                if i !=j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))

                            if self.nodelist[j].node.node_tpye == 3:#列 平衡
                                sumBalance = sumBalance+1

                        else:#三绕组
                             if self.transformerlist3[j-node_num].trans_3.node_type == 1:#pq
                                 Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                 Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                                 sumPQ = sumPQ+1

                             if self.transformerlist3[j-node_num].trans_3.node_type == 2:#pv
                                 Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))

                             if self.transformerlist3[j-node_num].trans_3.node_type == 3:#平衡
                                 sumBalance = sumBalance+1

                if self.nodelist[i].node.node_tpye == 3:
                    sumBalance_rank= sumBalance_rank+1

            else:#行为三绕组

                if self.transformerlist3[i-node_num].trans_3.node_tpye == 1:#pq
                    for j in range(n):
                        if j<node_num:
                            if self.nodelist[j].node.node_tpye == 1:
                                if i == j:
                                    q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] =self.Ui[i]*q_sum+2*self.Ui[i]*self.Ui[i]*self.ad_matrix[i][i].real
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] =self.Ui[i]*q_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance+1 ]=self.Ui[i]*p_sum-2*self.Ui[i]*self.Ui[i]*self.ad_matrix[i][i].imag
                                if i !=j:

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] = -Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1]
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance+1 ] = Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance]

                                sumPQ = sumPQ+1
                            if self.nodelist[j].node.node_tpye == 2:
                                if i == j:
                                    q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] =self.Ui[i]*q_sum
                                if i !=j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] = -self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                            if self.nodelist[j].node.node_tpye == 3:
                                sumBalance = sumBalance+1
                        else:
                            if self.transformerlist3[j-node_num].trans_3.node_type == 1:
                                if i == j:
                                    q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] =self.Ui[i]*q_sum+2*self.Ui[i]*self.Ui[i]*self.ad_matrix[i][i].real
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] =self.Ui[i]*q_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance+1 ]=self.Ui[i]*p_sum-2*self.Ui[i]*self.Ui[i]*self.ad_matrix[i][i].imag
                                if i != j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] = -Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1]
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance+1 ] = Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance]
                                sumPQ = sumPQ+1
                            if self.transformerlist3[j-node_num].trans_3.node_type == 2:
                                if i == j:
                                    q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] =self.Ui[i]*q_sum
                                if i!=j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank+1][j+sumPQ-sumBalance] = -self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                            if self.transformerlist3[j-node_num].trans_3.node_type == 3:
                                sumBalance = sumBalance+1
                    sumPQ_rank=sumPQ_rank+1




                if self.transformerlist3[i-node_num].trans_3.node_tpye == 2:
                    for j in range(n):
                        if j < node_num:
                            if self.nodelist[j].node.node_tpye == 1:
                                if i == j:
                                    q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] =self.Ui[i]*q_sum+2*self.Ui[i]*self.Ui[i]*self.ad_matrix[i][i].real
                                if i !=j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] = self.Ui[i]*self.Ui[j](*self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))

                                sumPQ = sumPQ+1
                            if self.nodelist[j].node.node_tpye == 2:
                                if i == j:
                                    # q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            #        q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                if i !=j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                            if self.nodelist[j].node.node_tpye == 3:
                                sumBalance = sumBalance+1
                        else:
                            if self.transformerlist3[j-node_num].trans_3.node_type == 1:

                                Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                                Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance+1] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.cos(math.radians(self.Angle[i]-self.Angle[j]))+self.ad_matrix[i][j].imag*math.sin(math.radians(self.Angle[i]-self.Angle[j])))
                                sumPQ = sumPQ+1
                            if self.transformerlist3[j-node_num].trans_3.node_type == 2:
                                if i == j:
                                    # q_sum = 0
                                    p_sum = 0
                                    for h in range(n):
                                        if h != i:
                                            #        q_sum =q_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.cos(math.radians(self.Angle[i]-self.Angle[h]))+self.ad_matrix[i][h].imag*math.sin(math.radians(self.Angle[i]-self.Angle[h])))
                                            p_sum =p_sum+self.Ui[h]*(self.ad_matrix[i][h].real*math.sin(math.radians(self.Angle[i]-self.Angle[h]))-self.ad_matrix[i][h].imag*math.cos(math.radians(self.Angle[i]-self.Angle[h])))

                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = -self.Ui[i]*p_sum
                                if i != j:
                                    Jaccobi_martix[i+sumPQ_rank-sumBalance_rank][j+sumPQ-sumBalance] = self.Ui[i]*self.Ui[j]*(self.ad_matrix[i][j].real*math.sin(math.radians(self.Angle[i]-self.Angle[j]))-self.ad_matrix[i][j].imag*math.cos(math.radians(self.Angle[i]-self.Angle[j])))
                            if self.transformerlist3[j-node_num].trans_3.node_type == 3:
                                sumBalance = sumBalance+1

                if self.transformerlist3[i-node_num].trans_3.node_tpye == 3:
                    sumBalance_rank= sumBalance_rank+1








        return (Jaccobi_martix)
    #更新U ANGEL
    def update_U_Aagel(self):
        sum_pq = 0
        sum_balance = 0
        num = len(self.nodelist)
        for i in range(len(self.nodelist)):
            if self.nodelist[i].node.node_tpye == 1:
                self.Ui[i] =self.Ui[i]+self.offset[i+sum_pq-sum_balance+1]*self.Ui[i]
                self.Angle[i] = self.Angle[i]+math.degrees(self.offset[i+sum_pq-sum_balance])
                sum_pq = sum_pq+1
            if self.nodelist[i].node.node_tpye == 2:
                self.Angle[i] = self.Angle[i]+math.degrees(self.offset[i+sum_pq-sum_balance])
            if self.nodelist[i].node.node_tpye == 3:
                sum_balance = sum_balance+1
        for i in range(len(self.transformerlist3)):
            if self.transformerlist3[i].trans_3.node_tpye == 1:
                self.Ui[num+i] =self.Ui[num+i]+self.offset[i+num+sum_pq-sum_balance+1]*self.Ui[num+i]
                self.Angle[num+i] = self.Angle[num+i]+math.degrees(self.offset[num+i+sum_pq-sum_balance])
                sum_pq = sum_pq+1
            if self.transformerlist3[i].trans_3.node_tpye == 2:
                self.Angle[num+i] = self.Angle[num+i]+math.degrees(self.offset[num+i+sum_pq-sum_balance])
            if self.transformerlist3[i].trans_3.node_tpye == 3:
                sum_balance = sum_balance+1

    def caulcunate_kernel(self):
        i = 0
        start_time = time.time()
        while(1):

            a = self.power_flow_equation()
            self.error = self.P_Q_real-a
            j = self.Jaccobi_calcuate()
            try:
                self.textEdit.clear()
                #print(np.linalg.inv(j))

                print(self.error)
                a = np.linalg.inv(j)
                self.offset = a@self.error
                # print(self.Ui)
                # print(self.Angle)
                #print(self.offset)
                self.update_U_Aagel()
                # print(self.Ui)
                # print(self.Angle)
                max_index = np.abs(self.offset).argmax()
                i = i+1
                if i > 100 or abs(self.offset.flat[max_index])<self.limit:
                    if abs(self.offset.flat[max_index])<self.limit:
                        self.textEdit.append("success")
                        end_time = time.time()
                        self.textEdit.append("Finish in {:.10f}s".format(end_time-start_time))
                        self.textEdit.append("迭代次数:{}".format(i))
                        self.node_update()
                    break
                #print(i)
            except :
                info = traceback.format_exc()
                #print(info)
                #print(traceback.print_exc())
                self.textEdit.clear()
                if np.linalg.det(j) == 0:
                    self.textEdit.append("jaccobi矩阵不可逆")
                else:
                    self.textEdit.append("traceback.print_exc()")

                break
#更新显示
    def node_update(self):
        num = len(self.nodelist)
        for i in range(num):
            self.nodelist[i].node.node_v = self.Ui[i]
            self.nodelist[i].node.node_angle = self.Angle[i]
        for i in range(len(self.transformerlist3)):
            self.transformerlist3[i].trans_3.node_v = self.Ui[i+num]
            self.transformerlist3[i].trans_3.node_angle = self.Angle[i+num]








"""         
停靠窗口
"""
if __name__ == "__main__" :
    app = QtWidgets.QApplication(sys.argv)
    main = Ui_MainWindow()
    main.setupUi()
    main.show()
    sys.exit(app.exec_())
